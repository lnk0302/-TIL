# Cub3d

Date: 2021/04/06
Language: C

## 오늘 한 일

---

1. `sprite` 구현시 그래픽 출력 오류 수정
    - 오류가 발생하는 구간은 캐스팅 한  `ray` 와 `sprite` 의 각이 -3.12, -3.13, -3.14 , 3.14, 3.13, 3.12 ... 와 같이 최소각에서 최대각으로 넘어가면서 발생함.

         → 음수값을 적절히 조절하여 3.12, 3.13, 3.14 ~ 0.1, 0.2, ... 와 같은 값을 가지도록 수정

2. memory leak 막기!
    - leak test를 하여 메모리 누수가 발생함을 확인하였다.
    - 이때 메모리 누수 특징은 다음과 같았다.

        → 누수 메모리의 갯수 = map의 행을 parse 하는 횟수 - 1

        → 누수의 바이트 수 = 첫번째 : `sizof(map[0])` // 두번째 :  `sizof(map[0])+sizof(map[1])` // 세번째 :  `sizof(map[0])+sizof(map[1])+sizof(map[2])` ... 계속

    - 이와 같은 특징 덕분에 초기에 map.cub 파일을 `open` 하여 buffer에 쓰는 과정중에 발생함을 예상할 수 있었다. (dongklee님이 큰 도움을 주셨다!)

    ```c
    while ; do leaks $(target) ; sleep 3; clear ; done
    ```

3. BUS ERROR 발생! - bus error를 잡기위한 여정
    - map.cub 파일의 input 값을 바꿔가며 테스트 하던 중 간헐적으로 `bus error`가 발생함을 확인
    - 이때 메모리 누수 특징은 다음과 같았다.

        → map data로 입력되는 지도의 `row(행)이 3, 5, 7 과 같이 홀수 일 때` 자주 발생한다.

        → 그럼에도 때에 따라  정상적으로 프로그램이 작동할 때도 있다.

    - 이에 다음과 같은 순서로 발생지점을 체크하였다.
        1.  map data를 다루면서, `정해진 메모리 범위를 벗어나 값을 쓰는 행위가 발생할 수 있는 부분`
            - map data를 parse하여 정렬하여 동적할당 한 array에 쓰는 함수들을 check
            - parsing, valid check, dfs 모든 파트를 살펴봤지만, 해당부분에서는 별다른 문제가 없었다.
        2. mlx의 img 포인터를 다루는 부분과 ray casting 관련 부분
            - 이 부분은 하나하나 함수를 뜯어보며 어느부분이 문제인가 확인하기가 어려워, 각 함수를 on/off를 하면서 check 하였다.
            - 놀랍게도 전혀 관계 없을거라 생각했던 ray casting부분에서 문제를 찾았다.
            - 화면에 mini map의 격자를 그려주는 함수가 문제였는데 정확히 `정해진 메모리 범위를 벗어나 값을 쓰는 행위가 발생` 할 수 있었고, 이는 map data 행이 홀수 일때 벌어질 수 밖에 없었다.

                → 해당 함수는 window에 출력하는 image에 비트맵을 입히는 역할을 하였다.

                → 문제는 다음과 같은 부분에서 발생하였다.

                ![Cub3d%20b76577ded100496193194bdfdb4a3adf/Untitled.png](Cub3d%20b76577ded100496193194bdfdb4a3adf/Untitled.png)

                ```c
                void m_map_grid(t_data *data)
                {
                	t_minimap *map = &(data->map);
                	int i;
                	int j;

                	i = 0;
                	while (i <= map->col)
                	{
                		v_put(&(data->draw.start), i * map->cub_width, map->h_offset);
                		v_put(&(data->draw.end), i * map->cub_width, map->h_offset + map->row * map->cub_height);
                		data->draw.color = 0x000000;
                		draw_line(data);
                		i++;
                	}
                	i = 0;
                	**while (i <= map->row)  문제의 while문**
                	{
                		v_put(&(data->draw.start), 0, map->h_offset + i * map->cub_height);
                		v_put(&(data->draw.end), map->col * map->cub_width, map->h_offset + i * map->cub_height);
                		data->draw.color = 0x000000;
                		draw_line(data);
                		i++;
                	}
                }
                ```

                → mini map의 수직 격자를 그릴 경우, index의 참조의 범위를 col과 같을 때 까지 하여야 mini map의 테두리가(미니맵의 최 우측) 출력됐다.

                → 하지만 mini map의 수평 격자를 그릴 경우,  index의 참조의 범위를 row와 같을 때 까지 하면 row의 값이 홀수 일때 row image의 최하단 경계를 벗어나면서 잘못된 메모리에 값을 쓰게 되는 것.

                → 이에  while 문 조건의 index 대소 관계에서 `=` 를 빼주는 것으로 해결하였다.

---

## 내일 할 일

---

1. 

---